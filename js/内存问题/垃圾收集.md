# 垃圾收集

> javascript自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存。

## 原理描述
找出不再继续使用的变量，然后释放其占用的内存。垃圾收集器会按照一定的时间间隔进行回收的工作。

## 具体机制
垃圾收集器跟踪哪个变量有用，哪个变量没有用，然后对于不再有用的变量需要打上标记，以备将来回收其占用的内存。用于标记无用的变量的策略主要有两种。
### 标记清除
当变量进入环境之后，垃圾收集器就将该变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为一旦进入环境就有可能会用到它们。当变量离开环境的时候，需要将它们标记为“离开环境”。
可以使用任何的方式来标记变量。比如，可以翻转某个特殊的位来标记一个变量何时进入环境，或者使用一个“进入环境的”列表及在列表中的一个“离开环境的”列表来记录变量的标记。所以，**怎么标记一个列表并不重要，重要的是采取什么策略进行标记。**
垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量以及被环境变量引用的变量的标记。而在此之后，再被加上标记的变量就会被视为准备挨删除的变量。原因：环境中无法再访问到变量。

### 引用计数
##### 含义：跟踪记录一个值被引用的次数。   

当声明了一个变量，并且将一个引用类型值赋给了该变量的时候，其引用次数为1。如果同一个值又被赋给其他的变量，那么它的引用次数继续加1.如果包含这个值的引用的变量又取得了新的另外的值，那么其引用次数-1.直到其引用次数变为0，当下次垃圾收集器运行的时候，就可以将其回收。

----
##### 缺点
如果存在循环引用的话，没办法将其回收。上代码：
    
    function problem(){
        var objectA = new Object();
        var objectB = new Object();
        
        objectA.someOtherObject = ObjectB;
        objectB.anotherObject = objectA;   
    }

objectA和ObjectB之间存在属性的互相引用。其引用次数一定是2，当函数执行结束之后仍然会存在，所以，两种方式前者更好。但是，IE中，有一些对象不是原生的js对象，如BOM何DOM对象，采用的收集机制就是引用计数。而为了规避循环引用的问题我们需要手动断开连接。仍上代码解释：
    
      var element = document.getElementById('some_element');
      var myObject = new Object();
      myObject.element = element;
      element.someObject = myObject;
      //.....其他操作
      myObject.element = null;
      element.someObject = null;
手动断开连接之后，下次垃圾收集器运行就会回收它们。
PS.在IE9之后的浏览器已经将BOM和DOM转为了js对象。